# импорт библиотек и модулей
from math import floor
from pprint import pprint


# Нерешённый судоку
board = [
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
]
size = int(len(board))
box_size = int(size**0.5)
print(box_size, size**0.5, size)


# Проверка на возможность размещения
def validate(position: tuple, number: str) -> bool:
    # Разделяем координаты
    row, column = position

    # Проходимся по всем рядам
    for x in range(0, size, 1):
        # Проверка на валидность
        if board[x][column] == number and x != row:
            return False

    # Проходимся по всем колонкам
    for y in range(0, size, 1):
        # Проверка на валидность
        if board[row][y] == number and y != column:
            return False

    # Ищем координаты бокса
    box_row = int(floor(row / box_size) * box_size)
    box_column = int(floor(column / box_size) * box_size)

    # Проходимся по боксу
    # Координаты рядов бокса
    for x in range(box_row, (box_row + box_size), 1):
        # Координаты колонок бокса
        for y in range(box_column, (box_column + box_size), 1):
            # Проверка на валидность
            if board[x][y] == number and x != row and y != column:
                return False

    return True


# Поиск пустой ячейки
def find_empty() -> tuple | None:
    # Проходимся по всем рядам судоку
    for row in range(0, size, 1):
        # Проходимся по всем колонкам судоку
        for column in range(0, size, 1):
            # Находим первую пустую ячейку
            if board[row][column] in [".", ""]:
                # Возвращаем координаты ячейки
                return (row, column)
    return None


# Решение судоку
def solve() -> bool:
    # Получаем позицию пустой ячейки
    current_position = find_empty()

    # При решенном судоку возвращаем результата
    if current_position == None:
        return True

    # Проходимся по всем возможным цифрам
    for i in range(1, size + 1, 1):
        # Текущая цифра
        current_number = str(i)
        # Можно ли разместить текущую цифру на первой текущей позиции
        is_validate = validate(current_position, current_number)

        # Проверка на размещение
        if is_validate:
            # Разделяем координаты
            x, y = current_position
            # Присваиваем доске под текущими координатами текущее число
            board[x][y] = current_number
            # Рекурсия для дальнейшей доски
            if solve():
                return True

            # Возвращение пустой ячейки
            board[x][y] = "."

    # Нельзя решить судоку
    return False


if __name__ == "__main__":
    solve()
    print(board)


# YouTube: https://www.youtube.com/@Bocker
# Telegram: https://www.t.me/Python_Bocker
